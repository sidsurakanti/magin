```python
from manim import *

class scn(Scene):
    def construct(self):
        # Step 1: Function and Gradient Visualization
        # Layout A: Visuals left, Steps right, Narration bottom
        
        # Create coordinate system in left zone
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[-3, 3, 1],
            x_length=4,
            y_length=4,
            tips=False
        ).scale(0.8).to_edge(LEFT, buff=0.5)
        
        # Create contour lines for f(x,y) = x² + y²
        contours = VGroup()
        for r in [0.5, 1.0, 1.5, 2.0, 2.5]:
            circle = Circle(radius=r * 0.8, color=WHITE, stroke_width=1)
            circle.move_to(axes.c2p(0, 0))
            contours.add(circle)
        
        # Create gradient vectors at several points
        gradient_points = [(1, 0.5), (-1, 1), (0.5, -1), (-0.5, -0.5), (1.5, 1)]
        gradient_vectors = VGroup()
        
        for x, y in gradient_points:
            # Gradient of x² + y² is (2x, 2y)
            grad_x, grad_y = 2*x, 2*y
            # Scale down for visualization
            scale_factor = 0.3
            
            start_point = axes.c2p(x, y)
            end_point = axes.c2p(x + grad_x * scale_factor, y + grad_y * scale_factor)
            
            vector = Arrow(start_point, end_point, color=BLUE, buff=0, stroke_width=3, max_tip_length_to_length_ratio=0.2)
            gradient_vectors.add(vector)
        
        # Steps text in right zone
        step_text = MathTex(
            r"\text{At each point, the gradient vector}\\",
            r"\text{shows the steepest uphill direction}",
            font_size=20
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.2).to_edge(RIGHT, buff=0.5).shift(UP * 1.5)
        
        # Narration at bottom
        narration = Text("Gradients point in the direction of steepest increase", font_size=18).to_edge(DOWN, buff=0.3)
        
        # Animate step 1
        self.play(Create(axes), run_time=1)
        self.play(Create(contours), run_time=2)
        self.play(Create(gradient_vectors), run_time=2)
        self.play(Write(step_text), run_time=1.5)
        self.play(Write(narration), run_time=1.5)
        
        # Step 2: Gradient Magnitude Visualization
        self.wait(1)
        
        # Remove old content
        self.play(FadeOut(step_text), FadeOut(narration), run_time=0.5)
        
        # Create new gradient vectors with varying magnitudes
        new_gradient_vectors = VGroup()
        highlight_short = None
        highlight_long = None
        
        for i, (x, y) in enumerate(gradient_points):
            grad_x, grad_y = 2*x, 2*y
            # Vary scale factor based on distance from origin
            distance = (x**2 + y**2)**0.5
            scale_factor = 0.15 + distance * 0.1  # Closer to origin = shorter vectors
            
            start_point = axes.c2p(x, y)
            end_point = axes.c2p(x + grad_x * scale_factor, y + grad_y * scale_factor)
            
            vector = Arrow(start_point, end_point, color=BLUE, buff=0, stroke_width=3, max_tip_length_to_length_ratio=0.2)
            new_gradient_vectors.add(vector)
            
            # Mark short and long vectors for highlighting
            if i == 3:  # (-0.5, -0.5) - close to origin
                highlight_short = SurroundingRectangle(vector, color=YELLOW, buff=0.1)
            elif i == 4:  # (1.5, 1) - far from origin  
                highlight_long = SurroundingRectangle(vector, color=RED, buff=0.1)
        
        # New step text
        step_text2 = MathTex(
            r"\text{Longer vectors = steeper slope}\\",
            r"\text{Shorter vectors = gentler slope}",
            font_size=20
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.2).to_edge(RIGHT, buff=0.5).shift(UP * 1.5)
        
        # New narration
        narration2 = Text("Gradient magnitude shows how steep the slope is", font_size=18).to_edge(DOWN, buff=0.3)
        
        # Animate step 2
        self.play(Transform(gradient_vectors, new_gradient_vectors), run_time=2)
        self.play(Create(highlight_short), Create(highlight_long), run_time=1.5)
        self.play(Write(step_text2), run_time=1.5)
        self.play(Write(narration2), run_time=2)
        
        # Step 3: Mathematical Definition
        self.wait(1)
        
        # Remove old content
        self.play(
            FadeOut(gradient_vectors), 
            FadeOut(highlight_short), 
            FadeOut(highlight_long),
            FadeOut(step_text2), 
            FadeOut(narration2), 
            run_time=1
        )
        
        # Add point P at (2,1)
        point_P = Dot(axes.c2p(2, 1), color=RED, radius=0.08)
        
        # Mathematical definition in steps zone
        math_def = VGroup(
            MathTex(r"\nabla f = \left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)", font_size=22),
            MathTex(r"\text{For } f(x,y) = x^2 + y^2:", font_size=22),
            MathTex(r"\frac{\partial f}{\partial x} = 2x", font_size=22),
            MathTex(r"\frac{\partial f}{\partial y} = 2y", font_size=22)
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).shift(UP * 1)
        
        # New narration
        narration3 = Text("The gradient is the vector of partial derivatives", font_size=18).to_edge(DOWN, buff=0.3)
        
        # Animate step 3
        self.play(Create(point_P), run_time=1)
        self.play(Write(narration3), run_time=1.5)
        for line in math_def:
            self.play(Write(line), run_time=1.5)
            self.wait(0.5)
        
        # Step 4: Gradient Calculation
        self.wait(1)
        
        # Remove old narration
        self.play(FadeOut(narration3), run_time=0.5)
        
        # Calculation steps
        calc_steps = VGroup(
            MathTex(r"\text{At point } (2,1):", font_size=22),
            MathTex(r"\nabla f(2,1) = (2(2), 2(1))", font_size=22),
            MathTex(r"\nabla f(2,1) = (4, 2)", font_size=22)
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).shift(DOWN * 0.5)
        
        # Add gradient vector at point P
        grad_at_P = Arrow(
            axes.c2p(2, 1), 
            axes.c2p(2 + 4*0.2, 1 + 2*0.2), 
            color=BLUE, 
            buff=0, 
            stroke_width=4, 
            max_tip_length_to_length_ratio=0.15
        )
        
        # New narration
        narration4 = Text("Calculate gradient at point (2,1)", font_size=18).to_edge(DOWN, buff=0.3)
        
        # Animate step 4
        self.play(Write(narration4), run_time=1)
        
        # Shift math definition up and add calculation
        self.play(math_def.animate.shift(UP * 0.8), run_time=0.8)
        
        for i, line in enumerate(calc_steps):
            self.play(Write(line), run_time=1.2)
            if i < len(calc_steps) - 1:
                self.wait(0.3)
        
        self.play(Create(grad_at_P), run_time=1.5)
        
        # Step 5: Gradient Descent Application
        self.wait(1)
        
        # Remove old content
        self.play(
            FadeOut(math_def), 
            FadeOut(calc_steps), 
            FadeOut(point_P), 
            FadeOut(grad_at_P), 
            FadeOut(narration4), 
            run_time=1
        )
        
        # Gradient descent starting point
        start_point = Dot(axes.c2p(3, 2), color=GREEN, radius=0.08)
        
        # Create gradient descent path
        path_points = [(3, 2), (2.4, 1.6), (1.92, 1.28), (1.54, 1.02), (1.23, 0.82)]
        path_dots = VGroup()
        path_arrows = VGroup()
        
        for i in range(len(path_points)-1):
            x, y = path_points[i]
            next_x, next_y = path_points[i+1]
            
            # Current point
            dot = Dot(axes.c2p(x, y), color=GREEN, radius=0.06)
            path_dots.add(dot)
            
            # Arrow to next point
            arrow = Arrow(
                axes.c2p(x, y), 
                axes.c2p(next_x, next_y), 
                color=ORANGE, 
                buff=0.06, 
                stroke_width=3,
                max_tip_length_to_length_ratio=0.2
            )
            path_arrows.add(arrow)
        
        # Final point
        final_dot = Dot(axes.c2p(path_points[-1][0], path_points[-1][1]), color=GREEN, radius=0.08)
        final_highlight = SurroundingRectangle(final_dot, color=GREEN, buff=0.15)
        
        # Step explanation
        step_text5 = MathTex(
            r"\text{Move opposite to gradient direction}\\",
            r"\text{to go downhill}",
            font_size=20
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.2).to_edge(RIGHT, buff=0.5).shift(UP * 1.5)
        
        # New narration
        narration5 = Text("Gradient descent uses gradients to find minimum points", font_size=18).to_edge(DOWN, buff=0.3)
        
        # Animate step 5
        self.play(Write(narration5), run_time=1.5)
        self.play(Write(step_text5), run_time=1.5)
        self.play(Create(start_point), run_time=1)
        
        # Animate path progression
        for i in range(len(path_dots)):
            self.play(Create(path_dots[i]), run_time=0.8)
            if i < len(path_arrows):
                self.play(Create(path_arrows[i]), run_time=0.8)
                self.wait(0.3)
        
        self.play(Create(final_dot), run_time=1)
        self.play(Create(final_highlight), run_time=1)
        
        # Step 6: Summary
        self.wait(1.5)
        
        # Remove gradient descent elements
        self.play(
            FadeOut(start_point),
            FadeOut(path_dots),
            FadeOut(path_arrows),
            FadeOut(final_dot),
            FadeOut(final_highlight),
            FadeOut(step_text5),
            FadeOut(narration5),
            run_time=1.5
        )
        
        # Add single clean gradient vector
        clean_vector = Arrow(
            axes.c2p(1.5, 1), 
            axes.c2p(1.5 + 3*0.2, 1 + 2*0.2), 
            color=BLUE, 
            buff=0, 
            stroke_width=4,
            max_tip_length_to_length_ratio=0.15
        )
        
        # Summary points
        summary_points = VGroup(
            MathTex(r"\bullet \text{ Points in steepest increase direction}", font_size=20),
            MathTex(r"\bullet \text{ Magnitude shows steepness}", font_size=20),
            MathTex(r"\bullet \text{ Used in optimization algorithms}", font_size=20)
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).shift(UP * 1)
        
        # Final narration
        final_narration = Text("Gradients: direction of steepest increase, calculated from partial derivatives", font_size=18).to_edge(DOWN, buff=0.3)
        
        # Animate step 6
        self.play(Create(clean_vector), run_time=1.5)
        self.play(Write(final_narration), run_time=2)
        self.play(Write(summary_points), run_time=2.5)
        
        self.wait(2)
```
